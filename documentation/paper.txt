DTOADQ
September 27, 2017

In order to compute a normal of an SDF, you must perform a gradient approximation: the central distance onf the SDF at P. For example, the di erence
quotient:
(f (x + h) f (x))
h

The most obvious way to calculate this is the six-point gradient; where for each
axis you compute f (x + h) f (x h), and normalize the result. This returns
a vector pointing in the direction where the map's SDF changes the most: the
normal. A four point gradient is possible; as long as each each point of the
gradient is multiplied by epsilon before normalizing. The speedup from six to
four is worthwhile, as computing each gradient is expensive as it involves a sdf
map call. There are more utilities with gradients not yet currently provided
in DTOADQ but are worth mentioning; an additional normal call using an
alternative (higher-quality) SDF map can be used to compute a bumpmap.
Another possibility is to analyze the gradient by hand, making it possible to
cheaply compute the normal of simple primitives such as a sphere.

Rendering equation with solid angle:
Lo (P; !o ) = Lo (P; !o ) +

Z

fs (P; !i ; !o )Li (P; !i )cosi d!i

(1)

To get from solid angle to path, consider:
fs (v ! v_ ! v) = fs (P; !i ; !o )
(2)
Le (v ! v_ ) = Le (P; !o )
(3)
0
1
Le (v ! v_ ) = Le (v)Le (v ! v_ )
(4)
But DTOADQ [at least, for now], only has support for area-light. Thus consider:
1

Le (P; !o )  Le (P )
Le (v ! v) = L0e (v)

(5)
(6)
The cos term, used for the projected solid angle in irradiance, no longer
applies when dealing with area. Thus, there is now a generalized geometry
term, G, that converts a PDF with respect to solid area using Jacobian mapping,
which involves the inverse squared distance, and the cosine angle between the
geometric normals at v and v_ :
(coso cos_i )
jjv v_ jj2
Thus the rendering equation with respects to area is:
G(v $ v_ ) = V (v ! v_ )

Lo (v ! v_ ) = Le (v ! v_ )

Z

M

Li (v0 ! v1 )G(v0 $ v1 )fs (vk 1 ! vk )dA

(7)
(8)

where A is area, and M is the set of all possible paths length k. This is known as
the three-point form or the light transport equation. By recursively expanding
you can rewrite this as what will actually be worked with:
Ij =

Z

fj (v)d(v)

(9)

Where v is a path z0 ! zs ! yt ! y0 (eye ! light), is the subset of all
combination of paths of any length, and  is the union of these paths. Special
care has to be taken with the de nition of path itself, as in the source code,
there never exists a path v, only path z and y. Of course, to compute this, we
need to apply monte carlo sampling:
f (v)
Ij  j
(10)
p(v)
where p is the probability distribution function. We must use G here in
order to convert PDFs w.r.t. solid angle to area.
The amount that each path contributes to Ij di er greatly, so naively weighing each contribution by something like 1:0fs + t + 1 will producy very noisy
images, and would not be worth the additional computation time that BDPT
requires. In order to get good samples from the contributions, they must be
combined in an optimal manner using Multiple Importance Sampling, so the
equation now becomes:
W (v )
F = s t s;t s;t
(11)
ps;t (vs;t )
2

This can be rewritten to:
F  s t Cs;t = Ws;t (vs;t ) sL cs;t
Wst (x) =

E
t

Ps (h )
i Pi (x)

(12)
(13)

This can be rewritten to simplify implementation. PBR 3rd Ed, chapter 16
pg 1014-1016 explains in detail how to solve this while simplying the equation:

8
>
>
<1P:0(xf;i)  r (x); ii =< s;s;
i 1
ri (x) = !
P (xi )
>
!
P
(
x

)
> i 1  ri+1(x); i > s
:

(14)

P (xi 1 )

However, DTOADQ can simplify a bit further, as only the light path is
constructed rather both light and eye path. This means, while there is access to
any light vertex, the eye path is an input range with only minimum knowledge
about its previous two vertices. The paths remain seperated from each other:
there's no need to inverse the PDF ratio [the above requires so because there is
only one path, so the eye path, i > s is viewed in perspective of the light path].
Case i = 1 can also be expanded for clarity, as it is an alias to Pa
8
>
i = 0;
>
<1P:A0(f;xn) ;
i = 1;
Ri (x) = P!A (xn )
(15)
>
P
(
x

)
>
i
: !P (xi)  Ri 1(x); i > 1
And now the weighting function is the much simpler to handle
P (x ) G (x ) PA (xn )
Ri (x) = in=2 ( ! n ! n )  !
P (xn ) G (xn ) PA (xn )

(16)

1:0f
Rs 1 (y) + Rt 1 (z ) + 1:0f

(17)

Ws;t (y; z) =

Thus, the nal rendering equation for DTOADQ looks like such:
F

:0f 1
= 1N
0 s0 t0 sL cs;t tE Ws;t (y; z)
Pi (xs;t ) = PsL pEt

3

(18)
(19)

8
>
i = 0;
<1:0f;
LjE
pi (x) = PA (xi );
i = 1;
>
:P (xi 1 ! xi)G(xi 1 $ xi)PiLj1E ; i > 1
1

k=1

Z
M k+1

(20)

Le (v0 ! v1 )G(v0 $ v1 )ki=11 Fs (vi 1 ! vi ! vi+1 )G(vi $ vi+1 )
Wej (vk 1 ! vk )dA(v0 ) : : : dA(vk )

4


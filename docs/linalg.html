<html><head>
        <!-- Generated by Ddoc from ../../.dub/packages/gl3n-1.3.1/gl3n/linalg.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>gl3n.linalg</title>
        </head><body>
        <h1>gl3n.linalg</h1>
gl3n.<u>linalg</u>
<br><br>
Special thanks to:
<ul>  <li>Tomasz Stachowiak (h3r3tic): allowed me to use parts of <a href="https://bitbucket.org/h3r3tic/boxen/src/default/src/xf/omg">omg</a>.</li>
  <li>Jakob Ã˜vrum (jA_cOp): improved the code a lot!</li>
  <li>Florian Boesch (__doc__): helps me to understand opengl/complex maths better, see: <a href="http://codeflow.org/">http://codeflow.org/</a>.</li>
  <li>#D on freenode: answered general questions about D.</li>
</ul>

<br><br>
<b>Authors:</b><br>
David Herberth
<br><br>
<b>License:</b><br>
MIT

<br><br>
<b>Note:</b><br>
All methods marked with pure are weakly pure since, they all access an instance member.
All static methods are strongly pure.<br><br>

<dl><dt><big><a name="Vector"></a>struct <u>Vector</u>(type, int dimension_);
</big></dt>
<dd>Base template for all vector-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>dimension</td>
<td>specifies the dimension of the vector, can be 1, 2, 3 or 4</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> <u>Vector</u>!(<font color=blue>int</font>, 3) vec3i;

<font color=blue>alias</font> <u>Vector</u>!(<font color=blue>float</font>, 4) vec4;

<font color=blue>alias</font> <u>Vector</u>!(<font color=blue>real</font>, 2) vec2r;

</pre>
<br><br>

<dl><dt><big><a name="Vector.vt"></a>alias <u>vt</u> = type;
</big></dt>
<dd>Holds the internal type of the vector.<br><br>

</dd>
<dt><big><a name="Vector.dimension"></a>static const int <u>dimension</u>;
</big></dt>
<dd>Holds the <u>dimension</u> of the vector.<br><br>

</dd>
<dt><big><a name="Vector.vector"></a>vt[dimension] <u>vector</u>;
</big></dt>
<dd>Holds all coordinates, length conforms dimension.<br><br>

</dd>
<dt><big><a name="Vector.value_ptr"></a>const @property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the coordinates.<br><br>

</dd>
<dt><big><a name="Vector.as_string"></a>@property string <u>as_string</u>();
<br><a name="Vector.toString"></a>alias <u>toString</u> = as_string;
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the vector.<br><br>

</dd>
<dt><big><a name="Vector.x"></a>alias <u>x</u> = get_!'<u>x</u>';
<br><a name="Vector.u"></a>alias <u>u</u> = x;
<br><a name="Vector.s"></a>alias <u>s</u> = x;
<br><a name="Vector.r"></a>alias <u>r</u> = x;
<br><a name="Vector.y"></a>alias <u>y</u> = get_!'<u>y</u>';
<br><a name="Vector.v"></a>alias <u>v</u> = y;
<br><a name="Vector.t"></a>alias <u>t</u> = y;
<br><a name="Vector.g"></a>alias <u>g</u> = y;
<br><a name="Vector.z"></a>alias <u>z</u> = get_!'<u>z</u>';
<br><a name="Vector.b"></a>alias <u>b</u> = z;
<br><a name="Vector.p"></a>alias <u>p</u> = z;
<br><a name="Vector.w"></a>alias <u>w</u> = get_!'<u>w</u>';
<br><a name="Vector.a"></a>alias <u>a</u> = w;
<br><a name="Vector.q"></a>alias <u>q</u> = w;
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big><a name="Vector.e1"></a>enum Vector <u>e1</u>;
<br><a name="Vector.e2"></a>enum Vector <u>e2</u>;
</big></dt>
<dd>canonical basis for Euclidian space<br><br>

</dd>
<dt><big><a name="Vector.this"></a>this(Args...)(Args <i>args</i>);
<br>this(T)(T <i>vec</i>) if (is_vector!T &amp;&amp; is(T.vt : vt) &amp;&amp; T.dimension &gt;= dimension);
<br>this()(vt <i>value</i>);
</big></dt>
<dd>Constructs the vector.
<br><br>
If a single <i>value</i> is passed the vector, the vector will be cleared with this <i>value</i>.
<br><br>

If a vector with a higher dimension is passed the vector will hold the first values up to its dimension.
<br><br>

If mixed types are passed they will be joined together (allowed types: vector, static array, <i>vt</i>).

<br><br>
<b>Examples:</b><br>
<pre class="d_code">
vec4 v4 = vec4(1.0f, vec2(2.0f, 3.0f), 4.0f);

vec3 v3 = vec3(v4); <font color=green>// v3 = vec3(1.0f, 2.0f, 3.0f);
</font>
vec2 v2 = v3.xy; <font color=green>// swizzling returns a static array.
</font>
vec3 v3_2 = vec3(1.0f); <font color=green>// vec3 v3_2 = vec3(1.0f, 1.0f, 1.0f);
</font>
</pre>
<br><br>

</dd>
<dt><big><a name="Vector.isFinite"></a>const @property bool <u>isFinite</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="Vector.clear"></a>void <u>clear</u>(vt <i>value</i>);
</big></dt>
<dd>Sets all values of the vector to <i>value</i>.<br><br>

</dd>
<dt><big><a name="Vector.update"></a>void <u>update</u>(Vector!(vt, dimension) <i>other</i>);
</big></dt>
<dd>Updates the vector with the values from <i>other</i>.<br><br>

</dd>
<dt><big><a name="Vector.opDispatch"></a>const @property Vector!(vt, s.length) <u>opDispatch</u>(string s)();
</big></dt>
<dd>Implements dynamic swizzling.
<br><br>
<b>Returns:</b><br>
a Vector<br><br>

</dd>
<dt><big><a name="Vector.magnitude_squared"></a>const @property real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the vector.<br><br>

</dd>
<dt><big><a name="Vector.magnitude"></a>const @property real <u>magnitude</u>();
<br><a name="Vector.length_squared"></a>alias <u>length_squared</u> = magnitude_squared;
<br><a name="Vector.length"></a>alias <u>length</u> = magnitude;
</big></dt>
<dd>Returns the <u>magnitude</u> of the vector.<br><br>

</dd>
<dt><big><a name="Vector.normalize"></a>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the vector.<br><br>

</dd>
<dt><big><a name="Vector.normalized"></a>const @property Vector <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current vector.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="dot"></a>pure nothrow @safe T.vt <u>dot</u>(T)(const T <i>veca</i>, const T <i>vecb</i>) if (is_vector!T);
</big></dt>
<dd>Calculates the product between two vectors.<br><br>

</dd>
<dt><big><a name="cross"></a>pure nothrow @safe T <u>cross</u>(T)(const T <i>veca</i>, const T <i>vecb</i>) if (is_vector!T &amp;&amp; T.dimension == 3);
</big></dt>
<dd>Calculates the <u>cross</u> product of two 3-dimensional vectors.<br><br>

</dd>
<dt><big><a name="distance"></a>pure nothrow @safe T.vt <u>distance</u>(T)(const T <i>veca</i>, const T <i>vecb</i>) if (is_vector!T);
</big></dt>
<dd>Calculates the <u>distance</u> between two vectors.<br><br>

</dd>
<dt><big><a name="reflect"></a>pure nothrow @safe T <u>reflect</u>(T)(const T <i>vec</i>, const T <i>norm</i>) if (is_vector!T);
</big></dt>
<dd><u>reflect</u> a vector using a surface normal<br><br>

</dd>
<dt><big><a name="vec2"></a>alias <u>vec2</u> = Vector!(float, 2).Vector;
<br><a name="vec3"></a>alias <u>vec3</u> = Vector!(float, 3).Vector;
<br><a name="vec4"></a>alias <u>vec4</u> = Vector!(float, 4).Vector;
<br><a name="vec2d"></a>alias <u>vec2d</u> = Vector!(double, 2).Vector;
<br><a name="vec3d"></a>alias <u>vec3d</u> = Vector!(double, 3).Vector;
<br><a name="vec4d"></a>alias <u>vec4d</u> = Vector!(double, 4).Vector;
<br><a name="vec2i"></a>alias <u>vec2i</u> = Vector!(int, 2).Vector;
<br><a name="vec3i"></a>alias <u>vec3i</u> = Vector!(int, 3).Vector;
<br><a name="vec4i"></a>alias <u>vec4i</u> = Vector!(int, 4).Vector;
</big></dt>
<dd>Pre-defined vector types, the number represents the dimension and the last letter the type (none = float, d = double, i = int).<br><br>

</dd>
<dt><big><a name="Matrix"></a>struct <u>Matrix</u>(type, int rows_, int cols_) if (rows_ &gt; 0 &amp;&amp; cols_ &gt; 0);
</big></dt>
<dd>Base template for all matrix-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>rows_</td>
<td>rows of the matrix</td></tr>
<tr><td>cols_</td>
<td>columns of the matrix</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>float</font>, 4, 4) mat4;

<font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>double</font>, 3, 4) mat34d;

<font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>real</font>, 2, 2) mat2r;

</pre>
<br><br>

<dl><dt><big><a name="Matrix.mt"></a>alias <u>mt</u> = type;
</big></dt>
<dd>Holds the internal type of the matrix;<br><br>

</dd>
<dt><big><a name="Matrix.rows"></a>static const int <u>rows</u>;
</big></dt>
<dd>Holds the number of <u>rows</u>;<br><br>

</dd>
<dt><big><a name="Matrix.cols"></a>static const int <u>cols</u>;
</big></dt>
<dd>Holds the number of columns;<br><br>

</dd>
<dt><big><a name="Matrix.matrix"></a>mt[cols][rows] <u>matrix</u>;
</big></dt>
<dd>Holds the <u>matrix</u> <font color=red>row-major</font> in memory.<br><br>

</dd>
<dt><big><a name="Matrix.value_ptr"></a>const @property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns the pointer to the stored values as OpenGL requires it.
<br><br>
Note this will return a pointer to a <font color=red>row-major</font> matrix,
<br><br>

<font color=red>this means you've to set the transpose argument to GL_TRUE when passing it to OpenGL</font>.

<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// 3rd argument = GL_TRUE
</font>
glUniformMatrix4fv(programs.main.model, 1, GL_TRUE, mat4.translation(-0.5f, -0.5f, 1.0f).<u>value_ptr</u>);

</pre>
<br><br>

</dd>
<dt><big><a name="Matrix.as_string"></a>@property string <u>as_string</u>();
<br><a name="Matrix.toString"></a>alias <u>toString</u> = as_string;
</big></dt>
<dd>Returns the current matrix formatted as flat string.<br><br>

</dd>
<dt><big><a name="Matrix.as_pretty_string"></a>@property string <u>as_pretty_string</u>();
<br><a name="Matrix.toPrettyString"></a>alias <u>toPrettyString</u> = as_pretty_string;
</big></dt>
<dd>Returns the current matrix as pretty formatted string.<br><br>

</dd>
<dt><big><a name="Matrix.this"></a>this(Args...)(Args <i>args</i>);
<br>this(T)(T <i>mat</i>) if (is_matrix!T &amp;&amp; T.cols &gt;= cols &amp;&amp; T.rows &gt;= rows);
<br>this(T)(T <i>mat</i>) if (is_matrix!T &amp;&amp; T.cols &lt; cols &amp;&amp; T.rows &lt; rows);
<br>this()(mt <i>value</i>);
</big></dt>
<dd>Constructs the matrix:
<br><br>
If a single <i>value</i> is passed, the matrix will be cleared with this <i>value</i> (each column in each row will contain this <i>value</i>).
<br><br>

If a matrix with more rows and columns is passed, the matrix will be the upper left nxm matrix.
<br><br>

If a matrix with less rows and columns is passed, the passed matrix will be stored in the upper left of an identity matrix.
<br><br>

It's also allowed to pass vectors and scalars at a time, but the vectors dimension must match the number of columns and align correctly.

<br><br>
<b>Examples:</b><br>
<pre class="d_code">
mat2 m2 = mat2(0.0f); <font color=green>// mat2 m2 = mat2(0.0f, 0.0f, 0.0f, 0.0f);
</font>
mat3 m3 = mat3(m2); <font color=green>// mat3 m3 = mat3(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
</font>
mat3 m3_2 = mat3(vec3(1.0f, 2.0f, 3.0f), 4.0f, 5.0f, 6.0f, vec3(7.0f, 8.0f, 9.0f));

mat4 m4 = mat4.identity; <font color=green>// just an identity matrix
</font>
mat3 m3_3 = mat3(m4); <font color=green>// mat3 m3_3 = mat3.identity
</font>
</pre>
<br><br>

</dd>
<dt><big><a name="Matrix.isFinite"></a>const @property bool <u>isFinite</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="Matrix.clear"></a>void <u>clear</u>(mt <i>value</i>);
</big></dt>
<dd>Sets all values of the matrix to <i>value</i> (each column in each row will contain this <i>value</i>).<br><br>

</dd>
<dt><big><a name="Matrix.make_identity"></a>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current matrix an identity matrix.<br><br>

</dd>
<dt><big><a name="Matrix.identity"></a>static @property Matrix <u>identity</u>();
</big></dt>
<dd>Returns a <u>identity</u> matrix.<br><br>

</dd>
<dt><big><a name="Matrix.transpose"></a>void <u>transpose</u>();
</big></dt>
<dd>Transposes the current matrix;<br><br>

</dd>
<dt><big><a name="Matrix.transposed"></a>const @property Matrix!(mt, cols, rows) <u>transposed</u>();
</big></dt>
<dd>Returns a <u>transposed</u> copy of the matrix.<br><br>

</dd>
<dt><big><a name="Matrix.translation"></a>static Matrix <u>translation</u>(mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
<br>static Matrix <u>translation</u>(Vector!(mt, 3) <i>v</i>);
</big></dt>
<dd>Returns a <u>translation</u> matrix (3x3 and 4x4 matrices).<br><br>

</dd>
<dt><big><a name="Matrix.translate"></a>Matrix <u>translate</u>(mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
<br>Matrix <u>translate</u>(Vector!(mt, 3) <i>v</i>);
</big></dt>
<dd>Applys a translation on the current matrix and returns <i>this</i> (3x3 and 4x4 matrices).<br><br>

</dd>
<dt><big><a name="Matrix.scaling"></a>static Matrix <u>scaling</u>(mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
</big></dt>
<dd>Returns a <u>scaling</u> matrix (3x3 and 4x4 matrices);<br><br>

</dd>
<dt><big><a name="Matrix.scale"></a>Matrix <u>scale</u>(mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
</big></dt>
<dd>Applys a <u>scale</u> to the current matrix and returns <i>this</i> (3x3 and 4x4 matrices).<br><br>

</dd>
<dt><big><a name="Matrix.rotation"></a>static Matrix <u>rotation</u>(real <i>alpha</i>, Vector!(mt, 3) <i>axis</i>);
<br>static Matrix <u>rotation</u>(real <i>alpha</i>, mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotate_axis around an arbitrary <i>axis</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.xrotation"></a>static Matrix <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the x-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.yrotation"></a>static Matrix <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the y-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.zrotation"></a>static Matrix <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the z-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.rotatex"></a>Matrix <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the x-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.rotatey"></a>Matrix <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the y-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.rotatez"></a>Matrix <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the z-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.set_translation"></a>void <u>set_translation</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the translation of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.set_translation.2"></a>void <u>set_translation</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the translation from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.get_translation"></a>Matrix <u>get_translation</u>();
</big></dt>
<dd>Returns an identity matrix with the current translation applied (nxn matrices, n &gt;= 3)..<br><br>

</dd>
<dt><big><a name="Matrix.set_scale"></a>void <u>set_scale</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the scale of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.set_scale.2"></a>void <u>set_scale</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the scale from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.get_scale"></a>Matrix <u>get_scale</u>();
</big></dt>
<dd>Returns an identity matrix with the current scale applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.set_rotation"></a>void <u>set_rotation</u>(Matrix!(mt, 3, 3) <i>rot</i>);
</big></dt>
<dd>Copies <i>rot</i> into the upper left corner, the translation (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.get_rotation"></a>Matrix!(mt, 3, 3) <u>get_rotation</u>();
</big></dt>
<dd>Returns an identity matrix with the current rotation applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="Matrix.inverse"></a>const @property Matrix <u>inverse</u>();
</big></dt>
<dd>Returns an inverted copy of the current matrix (nxn matrices, 2 &gt;= n &lt;= 4).<br><br>

</dd>
<dt><big><a name="Matrix.invert"></a>void <u>invert</u>();
</big></dt>
<dd>Inverts the current matrix (nxn matrices, 2 &gt;= n &lt;= 4).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="mat2"></a>alias <u>mat2</u> = Matrix!(float, 2, 2).Matrix;
</big></dt>
<dd>Pre-defined matrix types, the first number represents the number of rows
<br><br>
and the second the number of columns, if there's just one it's a nxn matrix.
<br><br>

All of these matrices are floating-point matrices.<br><br>

</dd>
<dt><big><a name="Quaternion"></a>struct <u>Quaternion</u>(type);
</big></dt>
<dd>Base template for all quaternion-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
</table><br>

<dl><dt><big><a name="Quaternion.qt"></a>alias <u>qt</u> = type;
</big></dt>
<dd>Holds the internal type of the quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.quaternion"></a>qt[4] <u>quaternion</u>;
</big></dt>
<dd>Holds the w, x, y and z coordinates.<br><br>

</dd>
<dt><big><a name="Quaternion.value_ptr"></a>const @property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the quaternion in memory, it starts with the w coordinate.<br><br>

</dd>
<dt><big><a name="Quaternion.as_string"></a>@property string <u>as_string</u>();
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.w"></a>alias <u>w</u> = get_!'<u>w</u>';
<br><a name="Quaternion.x"></a>alias <u>x</u> = get_!'<u>x</u>';
<br><a name="Quaternion.y"></a>alias <u>y</u> = get_!'<u>y</u>';
<br><a name="Quaternion.z"></a>alias <u>z</u> = get_!'<u>z</u>';
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big><a name="Quaternion.this"></a>this(qt <i>w_</i>, qt <i>x_</i>, qt <i>y_</i>, qt <i>z_</i>);
<br>this(qt <i>w_</i>, Vector!(qt, 3) <i>vec</i>);
<br>this(Vector!(qt, 4) <i>vec</i>);
</big></dt>
<dd>Constructs the quaternion.
<br><br>
Takes a 4-dimensional vector, where vector.x = the quaternions w coordinate,
<br><br>

or a w coordinate of type <i>qt</i> and a 3-dimensional vector representing the imaginary part,
<br><br>

or 4 values of type <i>qt</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.isFinite"></a>const @property bool <u>isFinite</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="Quaternion.magnitude_squared"></a>const @property real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.magnitude"></a>const @property real <u>magnitude</u>();
</big></dt>
<dd>Returns the <u>magnitude</u> of the quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.identity"></a>static @property Quaternion <u>identity</u>();
</big></dt>
<dd>Returns an <u>identity</u> quaternion (w=1, x=0, y=0, z=0).<br><br>

</dd>
<dt><big><a name="Quaternion.make_identity"></a>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current quaternion an identity quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.invert"></a>void <u>invert</u>();
<br><a name="Quaternion.conjugate"></a>alias <u>conjugate</u> = invert;
</big></dt>
<dd>Inverts the quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.inverse"></a>const @property Quaternion <u>inverse</u>();
<br><a name="Quaternion.conjugated"></a>alias <u>conjugated</u> = inverse;
</big></dt>
<dd>Returns an inverted copy of the current quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.from_matrix"></a>static Quaternion <u>from_matrix</u>(Matrix!(qt, 3, 3) <i>matrix</i>);
</big></dt>
<dd>Creates a quaternion from a 3x3 <i>matrix</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix!(qt, 3, 3) <i>matrix</i></td>
<td>3x3 <i>matrix</i> (rotation)</td></tr>
</table><br>
<b>Returns:</b><br>
A quaternion representing the rotation (3x3 <i>matrix</i>)<br><br>

</dd>
<dt><big><a name="Quaternion.to_matrix"></a>const Matrix!(qt, rows, cols) <u>to_matrix</u>(int rows, int cols)() if (rows &gt;= 3 &amp;&amp; cols &gt;= 3);
</big></dt>
<dd>Returns the quaternion as matrix.
<br><br>
<b>Params:</b><br>
<table><tr><td>rows</td>
<td>number of rows of the resulting matrix (min 3)</td></tr>
<tr><td>cols</td>
<td>number of columns of the resulting matrix (min 3)</td></tr>
</table><br>

</dd>
<dt><big><a name="Quaternion.normalize"></a>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the current quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.normalized"></a>const Quaternion <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current quaternion.<br><br>

</dd>
<dt><big><a name="Quaternion.yaw"></a>const @property real <u>yaw</u>();
</big></dt>
<dd>Returns the <u>yaw</u>.<br><br>

</dd>
<dt><big><a name="Quaternion.pitch"></a>const @property real <u>pitch</u>();
</big></dt>
<dd>Returns the <u>pitch</u>.<br><br>

</dd>
<dt><big><a name="Quaternion.roll"></a>const @property real <u>roll</u>();
</big></dt>
<dd>Returns the <u>roll</u>.<br><br>

</dd>
<dt><big><a name="Quaternion.xrotation"></a>static Quaternion <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the x-axis.<br><br>

</dd>
<dt><big><a name="Quaternion.yrotation"></a>static Quaternion <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the y-axis.<br><br>

</dd>
<dt><big><a name="Quaternion.zrotation"></a>static Quaternion <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the z-axis.<br><br>

</dd>
<dt><big><a name="Quaternion.axis_rotation"></a>static Quaternion <u>axis_rotation</u>(real <i>alpha</i>, Vector!(qt, 3) <i>axis</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around an <i>axis</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.euler_rotation"></a>static Quaternion <u>euler_rotation</u>(real <i>roll</i>, real <i>pitch</i>, real <i>yaw</i>);
</big></dt>
<dd>Creates a quaternion from an euler rotation.<br><br>

</dd>
<dt><big><a name="Quaternion.rotatex"></a>Quaternion <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the x-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.rotatey"></a>Quaternion <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the y-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.rotatez"></a>Quaternion <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the z-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.rotate_axis"></a>Quaternion <u>rotate_axis</u>(real <i>alpha</i>, Vector!(qt, 3) <i>axis</i>);
</big></dt>
<dd>Rotates the current quaternion around an <i>axis</i> and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="Quaternion.rotate_euler"></a>Quaternion <u>rotate_euler</u>(real <i>heading</i>, real <i>attitude</i>, real <i>bank</i>);
</big></dt>
<dd>Applies an euler rotation to the current quaternion and returns <i>this</i>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="quat"></a>alias <u>quat</u> = Quaternion!float.Quaternion;
</big></dt>
<dd>Pre-defined quaternion of type float.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>

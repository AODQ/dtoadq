<html><head>
        <!-- Generated by Ddoc from source/AODCore/entity.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>AODCore.entity</title>
        </head><body>
        <h1>AODCore.entity</h1>
Entities are what the engine uses to render images to the screen. They also
  support collision detection.
<br><br>
<b>Example:</b><br>
<pre class="d_code">  <font color=green>// To create your own entity class
</font>  <font color=blue>class</font> Player {
  <font color=blue>public</font>:
    <font color=blue>this</font>() {
      <font color=blue>super</font>(); <font color=green>// Make sure to call this
</font>      Set_Sprite(Img); <font color=green>// sets sprite
</font>      Set_Size(32, 32, <font color=blue>true</font>); <font color=green>// Set the image &amp; collision size to 32x32 pixels
</font>    }
    <font color=blue>override</font> <font color=blue>void</font> Update() {
      <font color=blue>static</font> <font color=blue>int</font> time = 0;
      ++ time;
      Set_Position(Vector(cos(time), sin(time)));
    }
  }

  <font color=green>// and then to add to the engine
</font>  <font color=blue>auto</font> player = <font color=blue>new</font> Player();
  AOD.Add(player);
</pre>
<br><br>

<dl><dt><big><a name="Entity"></a>class <u>Entity</u>: <u>AODCore.render_base.Render_Base</u>;
</big></dt>
<dd>A basic entity class. If you want collision support you should perhaps use
  AABBEntity or PolyEntity<br><br>

<dl><dt><big><a name="Entity.this"></a>this(ubyte <i>_layer</i> = 5, Type <i>_type</i> = Type.nil);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>ubyte <i>_layer</i></td>
<td>Layer that the entity should be rendered (0 is top)</td></tr>
<tr><td>Type <i>_type</i></td>
<td>Type of Entity</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Clicked"></a>bool <u>Clicked</u>(bool <i>offset</i>);
</big></dt>
<dd>Returns <b>true</b> if the entity is clicked
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>offset</i></td>
<td>If <b>true</b> the check will be adjusted for camera <i>offset</i> (generally set
               this to <b>false</b> for non-static objects)</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Clicked_On"></a>bool <u>Clicked_On</u>(bool <i>offset</i>);
</big></dt>
<dd>Returns <b>true</b> if the entity was clickd on this frame
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>offset</i></td>
<td>If <b>true</b> the check will be adjusted for camera <i>offset</i> (generally set this
              to <b>false</b> for non-static objects)</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Sprite"></a>void <u>Set_Sprite</u>(GLuint <i>index</i>, bool <i>reset_size</i> = 0);
</big></dt>
<dd>Sets current image to render for this entity
<br><br>
<b>Params:</b><br>
<table><tr><td>GLuint <i>index</i></td>
<td>GL Image to render</td></tr>
<tr><td>bool <i>reset_size</i></td>
<td>If the size of this entity (and image) should be resized
                      to <i>index</i>' size</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Sprite.2"></a>void <u>Set_Sprite</u>(SheetContainer <i>sc</i>, bool <i>reset_size</i> = 0);
</big></dt>
<dd>Sets a sheetcontainer to render this entity
<br><br>
<b>Params:</b><br>
<table><tr><td>SheetContainer <i>sc</i></td>
<td></td></tr>
<tr><td>bool <i>reset_size</i></td>
<td>If <b>true</b>, entity size will be set to image_size
                  (<i>sc</i>.width/height)</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Sprite.3"></a>void <u>Set_Sprite</u>(SheetRect <i>sr</i>, bool <i>reset_size</i> = 0);
</big></dt>
<dd>Sets a sheetrect to render this entity
<br><br>
<b>Params:</b><br>
<table><tr><td>SheetRect <i>sr</i></td>
<td></td></tr>
<tr><td>bool <i>reset_size</i></td>
<td>If <b>true</b>, entity size will be set to image_size
                 (<i>sr</i>.width/height)</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.R_Sprite_Texture"></a>GLuint <u>R_Sprite_Texture</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Shader"></a>void <u>Set_Shader</u>(Shader <i>_shader</i>);
</big></dt>
<dd>Sets shader to render entity with<br><br>

</dd>
<dt><big><a name="Entity.R_Shader"></a>Shader <u>R_Shader</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Add_Rotation"></a>void <u>Add_Rotation</u>(float <i>r</i>);
</big></dt>
<dd>(radians)<br><br>

</dd>
<dt><big><a name="Entity.Set_Rotation"></a>void <u>Set_Rotation</u>(float <i>r</i>);
</big></dt>
<dd>(radians)<br><br>

</dd>
<dt><big><a name="Entity.R_Rotation"></a>float <u>R_Rotation</u>();
</big></dt>
<dd>(radians)<br><br>

</dd>
<dt><big><a name="Entity.Add_Velocity"></a>void <u>Add_Velocity</u>(Vector <i>force</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Velocity"></a>void <u>Set_Velocity</u>(Vector <i>vel</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Velocity.2"></a>void <u>Set_Velocity</u>(float <i>x</i>, float <i>y</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Torque"></a>void <u>Set_Torque</u>(float <i>t</i>);
</big></dt>
<dd>The amount added to rotation every update frame<br><br>

</dd>
<dt><big><a name="Entity.Set_Sprite_Frame"></a>void <u>Set_Sprite_Frame</u>(float <i>left_x</i>, float <i>top_y</i>, float <i>right_x</i>, float <i>bot_y</i>);
</big></dt>
<dd>Sets the subsection of the image to be rendered<br><br>

</dd>
<dt><big><a name="Entity.Set_UVs"></a>void <u>Set_UVs</u>(Vector <i>ul</i>, Vector <i>lr</i>, bool <i>reset_flip</i> = 1);
</big></dt>
<dd>Sets the UV directly<br><br>

</dd>
<dt><big><a name="Entity.R_UVs"></a>void <u>R_UVs</u>(ref Vector <i>left</i>, ref Vector <i>right</i>);
</big></dt>
<dd>Sets UV to passed in paremeters
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector <i>left</i></td>
<td>[ UV[2], UV[3] ]</td></tr>
<tr><td>Vector <i>right</i></td>
<td>[ UV[4], UV[5] ]</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.R_UV_Array"></a>auto <u>R_UV_Array</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Flip_X"></a>void <u>Flip_X</u>();
</big></dt>
<dd>sets flip of of X
<br><br>
sets flip of of Y
<br><br>

 Flips the image on the x-axis<br><br>

</dd>
<dt><big><a name="Entity.Flip_Y"></a>void <u>Flip_Y</u>();
</big></dt>
<dd>Flips the image on the y-axis<br><br>

</dd>
<dt><big><a name="Entity.Set_Size"></a>void <u>Set_Size</u>(Vector <i>vec</i>, bool <i>scale_image</i> = 0);
</big></dt>
<dd>Sets the size of the entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector <i>vec</i></td>
<td>Size of the entity (in pixels)</td></tr>
<tr><td>bool <i>scale_image</i></td>
<td>If the size should scale the image as well</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.Set_Size.2"></a>void <u>Set_Size</u>(int <i>x</i>, int <i>y</i>, bool <i>scale_image</i> = 0);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Set_Image_Size"></a>void <u>Set_Image_Size</u>(Vector <i>vec</i>);
</big></dt>
<dd>Sets the size of the image itself, does not affect the entity<br><br>

</dd>
<dt><big><a name="Entity.R_Size"></a>Vector <u>R_Size</u>();
</big></dt>
<dd><b>Returns:</b><br>
size of the entity itself<br><br>

</dd>
<dt><big><a name="Entity.R_Img_Size"></a>Vector <u>R_Img_Size</u>();
</big></dt>
<dd><b>Returns:</b><br>
the size of the image<br><br>

</dd>
<dt><big><a name="Entity.Set_Colour"></a>void <u>Set_Colour</u>(float <i>r</i> = 1, float <i>g</i> = 1, float <i>b</i> = 1, float <i>a</i> = 1);
</big></dt>
<dd>Sets the colour of the image<br><br>

</dd>
<dt><big><a name="Entity.Cancel_Colour"></a>void <u>Cancel_Colour</u>();
</big></dt>
<dd>Cancels manually overriding the colour of the image<br><br>

</dd>
<dt><big><a name="Entity.Set_Origin"></a>void <u>Set_Origin</u>(Vector <i>v</i>);
</big></dt>
<dd>Sets the origin of the entity (default is the center of the image size)<br><br>

</dd>
<dt><big><a name="Entity.Clear_Origin"></a>void <u>Clear_Origin</u>();
</big></dt>
<dd>Resets origin to the center of the image size<br><br>

</dd>
<dt><big><a name="Entity.R_Origin"></a>Vector <u>R_Origin</u>();
</big></dt>
<dd><b>Returns:</b><br>
the current origin of the image<br><br>

</dd>
<dt><big><a name="Entity.Set_Position"></a>void <u>Set_Position</u>(T)(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Sets position based on any two types that are casteable to float<br><br>

</dd>
<dt><big><a name="Entity.Add_Position"></a>void <u>Add_Position</u>(T)(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Adds positionb ased on any two types that are casteable to float<br><br>

</dd>
<dt><big><a name="Entity.Set_Position.2"></a>void <u>Set_Position</u>(Vector <i>vec</i>);
</big></dt>
<dd>Sets position based off vector<br><br>

</dd>
<dt><big><a name="Entity.Set_PositionX"></a>void <u>Set_PositionX</u>(float <i>n</i>);
</big></dt>
<dd>Sets position X<br><br>

</dd>
<dt><big><a name="Entity.Set_PositionY"></a>void <u>Set_PositionY</u>(float <i>n</i>);
</big></dt>
<dd>Sets position Y<br><br>

</dd>
<dt><big><a name="Entity.Add_Position.2"></a>void <u>Add_Position</u>(Vector <i>vec</i>);
</big></dt>
<dd>Adds position based off vector<br><br>

</dd>
<dt><big><a name="Entity.R_Position"></a>Vector <u>R_Position</u>(bool <i>apply_static</i> = false);
</big></dt>
<dd>Returns current position
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>apply_static</i></td>
<td>If this or static_position is <b>false</b>, will modify
            returned position based off the camera</td></tr>
</table><br>

</dd>
<dt><big><a name="Entity.R_Green"></a>float <u>R_Green</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Red"></a>float <u>R_Red</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Blue"></a>float <u>R_Blue</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Alpha"></a>float <u>R_Alpha</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Coloured"></a>bool <u>R_Coloured</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Flipped_X"></a>bool <u>R_Flipped_X</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Flipped_Y"></a>bool <u>R_Flipped_Y</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Type"></a>Type <u>R_Type</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.R_Matrix"></a>Matrix <u>R_Matrix</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Entity.Prerender"></a>void <u>Prerender</u>();
</big></dt>
<dd>Called immediately before rendering this entity, used to change GLSL
      uniform values. Meant to be overriden<br><br>

</dd>
<dt><big><a name="Entity.Collision"></a>Collision_Info <u>Collision</u>(Entity <i>o</i>);
</big></dt>
<dd>Applies velocity/torque to entity (No need to call this)
<br><br>
Determines if there is a collision between this entity and another
<br><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the other<br><br>

</dd>
<dt><big><a name="Entity.Type"></a>enum <u>Type</u>: int;
</big></dt>
<dd>The collision type of entity<br><br>

</dd>
<dt><big><a name="Entity.image"></a>protected GLuint <u>image</u>;
</big></dt>
<dd>Current <u>image</u> to render to the screen<br><br>

</dd>
<dt><big><a name="Entity.rotation"></a>protected float <u>rotation</u>;
</big></dt>
<dd>Rotation in radians of object (and image)<br><br>

</dd>
<dt><big><a name="Entity.rotation_velocity"></a>protected float <u>rotation_velocity</u>;
</big></dt>
<dd>The amount added to rotation every update frame<br><br>

</dd>
<dt><big><a name="Entity.matrix"></a>protected Matrix <u>matrix</u>;
</big></dt>
<dd>Used to keep track of rotation, translation and scaling<br><br>

</dd>
<dt><big><a name="Entity.type"></a>protected Type <u>type</u>;
</big></dt>
<dd>Collision <u>type</u> of entity<br><br>

</dd>
<dt><big><a name="Entity.velocity"></a>protected Vector <u>velocity</u>;
</big></dt>
<dd>Amount added to position every update frame<br><br>

</dd>
<dt><big><a name="Entity.size"></a>protected Vector <u>size</u>;
</big></dt>
<dd>Scale of the object (for collision, does not affect image)<br><br>

</dd>
<dt><big><a name="Entity.image_size"></a>protected Vector <u>image_size</u>;
</big></dt>
<dd>Size of image<br><br>

</dd>
<dt><big><a name="Entity.rotate_origin"></a>protected Vector <u>rotate_origin</u>;
</big></dt>
<dd>The origin of which to apply rotation. Origin default is in the middle
      of the image<br><br>

</dd>
<dt><big><a name="Entity.alpha"></a>protected float <u>alpha</u>;
</big></dt>
<dd>The <u>alpha</u> of the image<br><br>

</dd>
<dt><big><a name="Entity.flipped_x"></a>protected bool <u>flipped_x</u>;
</big></dt>
<dd>Determines if the image is flipped on the x-axis<br><br>

</dd>
<dt><big><a name="Entity.flipped_y"></a>protected bool <u>flipped_y</u>;
</big></dt>
<dd>Determines if the imagei s flipped on the y-axis<br><br>

</dd>
<dt><big><a name="Entity._UV"></a>protected GLfloat[8] <u>_UV</u>;
</big></dt>
<dd>The UV that determines how the image is rendered<br><br>

</dd>
<dt><big><a name="Entity.transformed"></a>protected bool <u>transformed</u>;
</big></dt>
<dd>Used to determine if the vertices entity need to be restructured<br><br>

</dd>
<dt><big><a name="Entity.shader"></a>protected Shader <u>shader</u>;
</big></dt>
<dd>Current <u>shader</u> to use to render this (<b>null</b> == no <u>shader</u>)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PolyEntity"></a>class <u>PolyEntity</u>: <u>AODCore.entity.Entity</u>;
</big></dt>
<dd>An entity that uses polygon collision (only supports convex polygons)<br><br>

<dl><dt><big><a name="PolyEntity.this"></a>this(ubyte <i>_layer</i> = 0);
</big></dt>
<dd>Constructs an entity that has no vertices<br><br>

</dd>
<dt><big><a name="PolyEntity.this.2"></a>this(Vector[] <i>vertices_</i>, Vector <i>off</i> = Vector(0, 0), ubyte <i>_layer</i> = 0);
</big></dt>
<dd>Constructs an entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector[] <i>vertices_</i></td>
<td>Vertices to construct polygon with (must be
                   convex and in counter-clockwise order)</td></tr>
<tr><td>Vector <i>off</i></td>
<td>Sets position of entity</td></tr>
<tr><td>ubyte <i>_layer</i></td>
<td>layer</td></tr>
</table><br>

</dd>
<dt><big><a name="PolyEntity.Set_Vertices"></a>void <u>Set_Vertices</u>(Vector[] <i>vertices_</i>, bool <i>reorder</i> = 1);
</big></dt>
<dd>Resets vertices of entity
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector[] <i>vertices_</i></td>
<td>Vertices to construct polygon with (must be convex)</td></tr>
<tr><td>bool <i>reorder</i></td>
<td>If set, the vertices will be ordered as CCW (if set to) 0
                      then <i>vertices_</i> MUST be in CCW order</td></tr>
</table><br>

</dd>
<dt><big><a name="PolyEntity.R_Vertices"></a>Vector[] <u>R_Vertices</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="PolyEntity.R_Transformed_Vertices"></a>Vector[] <u>R_Transformed_Vertices</u>(bool <i>force</i> = 0);
</big></dt>
<dd><b>Returns:</b><br>
Vertices transformed by the entity's matrix<br><br>

</dd>
<dt><big><a name="PolyEntity.Collision"></a>Collision_Info <u>Collision</u>(PolyEntity <i>poly</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another PolyEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>PolyEntity <i>poly</i></td>
<td>Another PolyEntity</td></tr>
<tr><td>Vector <i>velocity</i></td>
<td>Velocity for which to check collision</td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the <i>poly</i><br><br>

</dd>
<dt><big><a name="PolyEntity.Collision.2"></a>Collision_Info <u>Collision</u>(AABBEntity <i>aabb</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another AABBEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>AABBEntity <i>aabb</i></td>
<td>Another AABBEntity</td></tr>
<tr><td>Vector <i>velocity</i></td>
<td>Velocity for which to check collisio</td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the AABB<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="AABBEntity"></a>class <u>AABBEntity</u>: <u>AODCore.entity.PolyEntity</u>;
</big></dt>
<dd>NOT FUNCTIONAL!!!!!!!!
  An entity that supports Axis-Aligned-Bounding-Box collision (a rectangle with
  no rotation). If rotation is required, use a PolyEntity instead, however this
  does support collision with PolyEntity. (You will effectively save no memory
  at the moment from using this, but you will save computation when doing
  AABB-AABB collisions)<br><br>

<dl><dt><big><a name="AABBEntity.this"></a>this(ubyte <i>_layer</i> = 0, Vector <i>size</i> = Vector(0, 0));
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>ubyte <i>_layer</i></td>
<td></td></tr>
<tr><td>Vector <i>size</i></td>
<td>Size of the bounding-box</td></tr>
</table><br>

</dd>
<dt><big><a name="AABBEntity.this.2"></a>this(ubyte <i>_layer</i>, Vector <i>size</i> = Vector(0, 0), Vector <i>pos</i> = Vector(0, 0));
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>ubyte <i>_layer</i></td>
<td></td></tr>
<tr><td>Vector <i>size</i></td>
<td>Size of the bounding-box</td></tr>
<tr><td>Vector <i>pos</i></td>
<td>Position of the entity</td></tr>
</table><br>

</dd>
<dt><big><a name="AABBEntity.Collide"></a>Collision_Info <u>Collide</u>(AABBEntity <i>aabb</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another AABBEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>AABBEntity <i>aabb</i></td>
<td>Another AABBEntity</td></tr>
<tr><td>Vector <i>velocity</i></td>
<td>Velocity for which to check collision</td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the AABB<br><br>

</dd>
<dt><big><a name="AABBEntity.Collide.2"></a>Collision_Info <u>Collide</u>(PolyEntity <i>poly</i>, Vector <i>velocity</i>);
</big></dt>
<dd>Check collision with another PolyEntity
<br><br>
<b>Params:</b><br>
<table><tr><td>PolyEntity <i>poly</i></td>
<td>Another PolyEntity</td></tr>
<tr><td>Vector <i>velocity</i></td>
<td>Velocity for which to check collision</td></tr>
</table><br>
<b>Returns:</b><br>
Result of the collision in respects to this colliding onto the <i>poly</i><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Collision_Info"></a>struct <u>Collision_Info</u>;
</big></dt>
<dd>Gives information about a collision.<br><br>

<dl><dt><big><a name="Collision_Info.collision"></a>bool <u>collision</u>;
</big></dt>
<dd>Determines if there is currently a <u>collision</u><br><br>

</dd>
<dt><big><a name="Collision_Info.will_collide"></a>bool <u>will_collide</u>;
</big></dt>
<dd>Determines if there will be a collision if the velocity were added
       to the position<br><br>

</dd>
<dt><big><a name="Collision_Info.translation"></a>Vector <u>translation</u>;
</big></dt>
<dd>Gives the amount of <u>translation</u> required to no longer be colliding<br><br>

</dd>
<dt><big><a name="Collision_Info.projection"></a>Vector <u>projection</u>;
</big></dt>
<dd>The axis/<u>projection</u> of the collision<br><br>

</dd>
<dt><big><a name="Collision_Info.normal"></a>Vector <u>normal</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Collision_Info.obj"></a>PolyEntity <u>obj</u>;
</big></dt>
<dd>The object that was collided with<br><br>

</dd>
<dt><big><a name="Collision_Info.this"></a>this(bool <i>c</i>);
</big></dt>
<dd>basic form of Collision_Info
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>c</i></td>
<td>If there was a collision</td></tr>
</table><br>

</dd>
<dt><big><a name="Collision_Info.this.2"></a>this(ref Vector <i>t</i>, bool <i>c</i>, bool <i>wc</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector <i>t</i></td>
<td>Translation of the collision</td></tr>
<tr><td>bool <i>c</i></td>
<td>If there was a collision</td></tr>
<tr><td>bool <i>wc</i></td>
<td>If there will be a collision</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
